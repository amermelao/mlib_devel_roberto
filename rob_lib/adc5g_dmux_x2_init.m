function adc5g_dmux_x2_init(blk, varargin)

% Initialize and configure the 2 ASIA 5 GSps ADC

% Declare defaults to be used throughout
defaults = {...
    'use_adc0', 'on',...
    'input_mode_adc0', 'Two-channel -- A&C',...
    'use_adc1', 'on',...
    'input_mode_adc1', 'Two-channel -- A&C',...
    'adc_clk_rate', 42,...
    'using_ctrl', 'on',...
    'test_ramp', 'off',...
    'interleave', 'on'};

% Check to see if mask parameters have changed
if same_state(blk, 'gcb', gcb, 'defaults', defaults, varargin{:}), return, end
check_mask_type(blk, 'adc5g_dmux_x2');

clean_blocks(blk);
munge_block(blk, varargin{:});

% Get all the mask parameters and form the needed derivatives
input_mode_0 = get_var('input_mode_adc0', 'defaults', defaults, varargin{:});
input_mode_1 = get_var('input_mode_adc1', 'defaults', defaults, varargin{:});
use_adc0 = get_var('use_adc0', 'defaults', defaults, varargin{:});
use_adc1 = get_var('use_adc1', 'defaults', defaults, varargin{:});
adc_clk_rate = get_var('adc_clk_rate', 'defaults', defaults, varargin{:});
using_ctrl = get_var('using_ctrl', 'defaults', defaults, varargin{:});

% parametes neded for adc5g that aren't in the mask
demux = '1:1';
adc_bit_width = 8;

% Determine proper input names
if strcmp(input_mode_0, 'One-channel -- A'),
    inputs_0 = {'a'};
elseif strcmp(input_mode_0, 'One-channel -- C'),
    inputs_0 = {'c'};
elseif strcmp(input_mode_0, 'Two-channel -- A&C'),
    inputs_0 = {'a', 'c'};
else 
    error(['Unsupported input mode adc 0, duble click on the block to change,: ',input_mode_0]);
end

if strcmp(input_mode_1, 'One-channel -- A'),
    inputs_1 = {'a'};
elseif strcmp(input_mode_1, 'One-channel -- C'),
    inputs_1 = {'c'};
elseif strcmp(input_mode_1, 'Two-channel -- A&C'),
    inputs_1 = {'a', 'c'};
else 
    error(['Unsupported input mode adc 1, duble click on the block to change,: ',input_mode_1]);
end

% the port names

% for adc 0
port_names_0 = {...
    'adc0_user_data_i0',...
    'adc0_user_data_i1',...
    'adc0_user_data_i2',...
    'adc0_user_data_i3',...
    'adc0_user_data_i4',...
    'adc0_user_data_i5',...
    'adc0_user_data_i6',...
    'adc0_user_data_i7',...
    'adc0_user_data_q0',...
    'adc0_user_data_q1',...
    'adc0_user_data_q2',...
    'adc0_user_data_q3',...
    'adc0_user_data_q4',...
    'adc0_user_data_q5',...
    'adc0_user_data_q6',...
    'adc0_user_data_q7'};

samples_0 = length(port_names_0)/length(inputs_0);

% for adc 1
port_names_1 = {...
    'adc1_user_data_i0',...
    'adc1_user_data_i1',...
    'adc1_user_data_i2',...
    'adc1_user_data_i3',...
    'adc1_user_data_i4',...
    'adc1_user_data_i5',...
    'adc1_user_data_i6',...
    'adc1_user_data_i7',...
    'adc1_user_data_q0',...
    'adc1_user_data_q1',...
    'adc1_user_data_q2',...
    'adc1_user_data_q3',...
    'adc1_user_data_q4',...
    'adc1_user_data_q5',...
    'adc1_user_data_q6',...
    'adc1_user_data_q7'};

samples_1 = length(port_names_1)/length(inputs_1);

sample_sep = 60;

if(samples_0 ~= samples_1)
    error('both adc must have the same input mode');
end
% Remove all lines, will be redrawn later
delete_lines(blk);

% this anonimus function calculates de position for the blocks
posit = @(curr_x, cont, sample_sep, samples_, adc01) [curr_x, 100+adc01*70+(cont + adc01*2)*sample_sep*samples_, ...
                                                      curr_x+30 116+adc01*70+(cont + adc01*2)*sample_sep*samples_];
                                                  
positGate = @(curr_x, conti, contj,sample_sep, samples_, adc01)[curr_x 100+adc01*70+(conti + adc01*2)*sample_sep*samples_+contj*sample_sep,...
                                                                 curr_x+30 116+adc01*70+(conti + adc01*2)*sample_sep*samples_+contj*sample_sep];
% start drawing the internal componentes
% disp('cicle0');
for i=0:length(inputs_0)-1
    
    curr_x = 30;
    % Draw the input with appropriate name
    reuse_block(blk, [...
        'sim_adc0_', inputs_0{i+1}],...
        'built-in/inport',...
        'Position', posit(curr_x, i, sample_sep, samples_0, 0),...
        'Port', num2str(i+1));
    
    reuse_block(blk, [...
        'sim_adc1_', inputs_1{i+1}],...
        'built-in/inport',...
        'Position', posit(curr_x, i, sample_sep, samples_1, 1),...
        'Port', num2str(i+1));
    
    curr_x = curr_x + 60;
    % Set the input gains and connect to inports
    reuse_block(blk, [...
        'gain_adc0_', inputs_0{i+1}], ...
        'built-in/Gain',...
        'Position', posit(curr_x, i, sample_sep, samples_0, 0),...
        'Gain', num2str(2^(adc_bit_width-1)));
    add_line(blk, ['sim_adc0_', inputs_0{i+1}, '/1'],...
                  ['gain_adc0_', inputs_0{i+1}, '/1']);
              
    reuse_block(blk, [...
        'gain_adc1_', inputs_1{i+1}], ...
        'built-in/Gain',...
        'Position', posit(curr_x, i, sample_sep, samples_1, 1),...
        'Gain', num2str(2^(adc_bit_width-1)));
    add_line(blk, ['sim_adc1_', inputs_1{i+1}, '/1'],...
                  ['gain_adc1_', inputs_1{i+1}, '/1']);
             
    curr_x = curr_x + 60;
    % Add the bias blocks and connect to the gains              
    reuse_block(blk, [...
        'bias_adc0_', inputs_0{i+1}], ...
        'built-in/Bias',...
        'Position', posit(curr_x, i, sample_sep, samples_0, 0),...
        'Bias', num2str(2^(adc_bit_width-1)));
    add_line(blk, ['gain_adc0_', inputs_0{i+1}, '/1'],...
                  ['bias_adc0_', inputs_0{i+1}, '/1']);
              
    reuse_block(blk, [...
        'bias_adc1_', inputs_1{i+1}], ...
        'built-in/Bias',...
        'Position', posit(curr_x, i, sample_sep, samples_1, 1),...
        'Bias', num2str(2^(adc_bit_width-1)));
    add_line(blk, ['gain_adc1_', inputs_1{i+1}, '/1'],...
                  ['bias_adc1_', inputs_1{i+1}, '/1']);
              
    curr_x1 = curr_x;
%     disp('cicle');
    for j=0:samples_1-1 
        
        curr_x1 = curr_x1 + 120;
        reuse_block(blk, [...
            'downsample_adc1_', inputs_1{i+1}, num2str(j)], ...
            'dspsigops/Downsample',...
            'Position', positGate(curr_x1, i,j, sample_sep, samples_1, 1),...
            'N', num2str(samples_1),...
            'phase', num2str(j),...
            'ic', '0');
        
        try       
        set_param([blk, '/downsample_adc1_', inputs_1{i+1}, num2str(j)], ...
            'InputProcessing', 'Elements as channels (sample based)', ...
            'RateOptions', 'Allow multirate processing');
        catch
            error('block not fount, coundnt set config')
        end;
        
        add_line(blk, ['bias_adc1_', inputs_1{i+1}, '/1'],...
                      ['downsample_adc1_', inputs_1{i+1}, num2str(j), '/1']);
        
        curr_x1 = curr_x1 + 140;
        
        if j==0
            delay = 2;
        else
            delay = 1;
        end
        
        reuse_block(blk, [...
            'delay_adc1_', inputs_0{i+1}, num2str(j)], ...
            'simulink/Discrete/Integer Delay',...
            'Position', positGate(curr_x1, i,j, sample_sep, samples_1, 1),...
            'NumDelays', num2str(delay),...
            'vinit', '0');
        add_line(blk, ['downsample_adc1_', inputs_1{i+1}, num2str(j), '/1'],...
                      ['delay_adc1_', inputs_1{i+1}, num2str(j), '/1']);
                  
        curr_x1 = curr_x1 + 160;
        
        port_name_1 = clear_name([gcb, '_', port_names_1{i*samples_1 + j + 1}]);
        reuse_block(blk,...
            port_name_1,...
            'xbsIndex_r4/Gateway In',...
            'Position', positGate(curr_x1, i,j, sample_sep, samples_1, 1),...
            'arith_type', 'Unsigned',...
            'n_bits', num2str(adc_bit_width),...
            'bin_pt', '0',...
            'overflow', 'Wrap',...
            'quantization', 'Truncate');
        add_line(blk, ['delay_adc1_', inputs_0{i+1}, num2str(j), '/1'],...
                      [port_name_1, '/1']);
        
        curr_x1 = curr_x1 + 160;
                  
        reuse_block(blk,...
            ['adc1_',inputs_1{i+1}, num2str(j)],...
            'built-in/outport',...
            'Position', positGate(curr_x1, i,j, sample_sep, samples_1, 1),...
            'Port', num2str(i*samples_1 + j + 1));
        add_line(blk, [port_name_1, '/1'],...
                      ['adc1_',inputs_1{i+1}, num2str(j), '/1']);
                  
        curr_x1 = curr_x1 - 120 - 140 - 160 - 160;
    end
    
    for j=0:samples_0-1
        
        curr_x = curr_x + 120;
        % Add downsample blocks
        reuse_block(blk, [...
            'downsample_adc0_', inputs_0{i+1}, num2str(j)], ...
            'dspsigops/Downsample',...
            'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
            'N', num2str(samples_0),...
            'phase', num2str(j),...
            'ic', '0');
        
        
%         disp(['downsample_adc1_', inputs_1{i+1}, num2str(j)]);
        % Try to set options required for Downsample block of newer DSP blockset
        % versions, but not available in older versions.
        try
          set_param([blk, '/downsample_adc0_', inputs_0{i+1}, num2str(j)], ...
            'InputProcessing', 'Elements as channels (sample based)', ...
            'RateOptions', 'Allow multirate processing');
        catch
            error('block not fount, coundnt set config')
        end;

        add_line(blk, ['bias_adc0_', inputs_0{i+1}, '/1'],...
                      ['downsample_adc0_', inputs_0{i+1}, num2str(j), '/1']);
                  
        
              
        curr_x = curr_x + 140;
        % Add delay blocks to align the samples
        if j==0
            delay = 2;
        else
            delay = 1;
        end
        
        reuse_block(blk, [...
            'delay_adc0_', inputs_0{i+1}, num2str(j)], ...
            'simulink/Discrete/Integer Delay',...
            'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
            'NumDelays', num2str(delay),...
            'vinit', '0');
        add_line(blk, ['downsample_adc0_', inputs_0{i+1}, num2str(j), '/1'],...
                      ['delay_adc0_', inputs_0{i+1}, num2str(j), '/1']);
        
                          
        curr_x = curr_x + 160;
        % Add the gateway-in ports, should match the netlist port names
        port_name_0 = clear_name([gcb, '_', port_names_0{i*samples_0 + j + 1}]);
        reuse_block(blk,...
            port_name_0,...
            'xbsIndex_r4/Gateway In',...
            'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
            'arith_type', 'Unsigned',...
            'n_bits', num2str(adc_bit_width),...
            'bin_pt', '0',...
            'overflow', 'Wrap',...
            'quantization', 'Truncate');
        add_line(blk, ['delay_adc0_', inputs_0{i+1}, num2str(j), '/1'],...
                      [port_name_0, '/1']);
                  
       
        
        curr_x = curr_x + 160;
        % Now, let's do the output ports!
        reuse_block(blk,...
            ['adc0_',inputs_0{i+1}, num2str(j)],...
            'built-in/outport',...
            'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
            'Port', num2str(i*samples_0 + j + 1));
        add_line(blk, [port_name_0, '/1'],...
                      ['adc0_',inputs_0{i+1}, num2str(j), '/1']);
                  
        
    
        curr_x = curr_x - 120 - 140 - 160 - 160; % undo all x changes
        
    end
    
end

sample_sep = sample_sep + 2;
curr_x = 30;
% Finally, let's do the sync stream
% First, the input port
reuse_block(blk,...
    'adc0_sim_sync',...
    'built-in/inport',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
    'Port', num2str(i+2));

reuse_block(blk,...
    'adc1_sim_sync',...
    'built-in/inport',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_1, 1),...
    'Port', num2str(i+2));

curr_x = curr_x + 60;
% Now the gateway-in for the sync
sync_name_0 = clear_name([gcb, '_', 'adc0_sync']);
reuse_block(blk,...
	sync_name_0,...
    'xbsIndex_r4/Gateway In',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
    'arith_type', 'Boolean');
add_line(blk, 'adc0_sim_sync/1', [sync_name_0, '/1']);

sync_name_1 = clear_name([gcb, '_', 'adc1_sync']);
reuse_block(blk,...
	sync_name_1,...
    'xbsIndex_r4/Gateway In',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_1, 1),...
    'arith_type', 'Boolean');
add_line(blk, 'adc1_sim_sync/1', [sync_name_1, '/1']);

curr_x = curr_x + 160;
% And lastly the output port
reuse_block(blk,...
    'adc1_sync_out',...
    'built-in/outport',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_1, 1),...
    'Port', num2str(i*samples_1 + j + 2));
add_line(blk, [sync_name_1, '/1'], 'adc1_sync_out/1');

reuse_block(blk,...
    'adc0_sync_out',...
    'built-in/outport',...
    'Position', positGate(curr_x, i,j, sample_sep, samples_0, 0),...
    'Port', num2str(i*samples_0 + j + 2));
add_line(blk, [sync_name_0, '/1'], 'adc0_sync_out/1');




clean_blocks(blk);
save_state(blk, 'gcb', gcb, 'defaults', defaults, varargin{:});
